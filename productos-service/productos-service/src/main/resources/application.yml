spring:
  application:
    name: productos-service

  datasource:
    url: ${DATASOURCE-URL}
    username: ${DATASOURCE_USER}
    password: ${DATASOURCE_PASS}          # si realmente es vacío
    driver-class-name: com.mysql.cj.jdbc.Driver
    # opcional:
    hikari:
      maximum-pool-size: 10

  jpa:
    hibernate:
      ddl-auto: update
    # puedes omitir database-platform (autodetecta), o usar:
    database-platform: org.hibernate.dialect.MySQLDialect
    show-sql: true

  security:
    oauth2:
      resourceserver:
        jwt:
          # Opción A (la que ya usas):
          jwk-set-uri: ${JWK_SET_URI}
          # Opción B (en vez de la anterior):
          # issuer-uri: http://localhost:8181/realms/microservicios-realm

      client:
        registration:
          keycloak:
            client-id: ${CLIENT_ID}          # <-- el ID de tu cliente en Keycloak
            client-secret: ${CLIENT_SECRET}
            scope: openid,profile,email
            authorization-grant-type: authorization_code
            redirect-uri: "{baseUrl}/login/oauth2/code/keycloak"
        provider:
          keycloak:
            issuer-uri: ${ISSUER_URL}

keycloak:
  server-url: ${SERVER_URL}         # o 8080 si ese es tu KC
  realm: ${REALM}
  admin:
    client-id: ${CLIENT_ID}        # <-- debe ser un client CONFIDENTIAL con Service Accounts = ON
    client-secret: ${CLIENT_SECRET}          # <-- secret de ese client
  legacy-auth-path: false                   # true solo si tu KC usa /auth (Keycloak viejo)


server:
  port: 8081

eureka:
  client:
    service-url:
      defaultZone: ${DEFAULT_ZONE}
  instance:
    hostname: localhost
    prefer-ip-address: true
    ip-address: 127.0.0.1
    instance-id: ${spring.application.name}:${server.port}